/* 
**  mod_mod_log_syslog.c -- Apache sample mod_log_syslog module
**  [Autogenerated via ``apxs -n mod_log_syslog -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_mod_log_syslog.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /mod_log_syslog in as follows:
**
**    #   httpd.conf
**    LoadModule mod_log_syslog_module modules/mod_mod_log_syslog.so
**    <Location /mod_log_syslog>
**    SetHandler mod_log_syslog
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /mod_log_syslog and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/mod_log_syslog 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 APR_SUCCESS
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_mod_log_syslog.c
*/ 

#include <sys/uio.h>
#include <sys/syslog.h>
#include <apr_strings.h>
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "http_log.h"


#include "mod_log_config.h"

#ifndef APR_HAVE_SOCKADDR_UN
#include <sys/un.h>
#endif

#define MODULE_NAME "mod_log_syslog"
#define MODULE_VERSION "0.1.1"

#define CUSTOM_LOG_PREFIX "syslog:"
#define CUSTOM_LOG_FILE "/dev/log"

//#define USE_SENDV
//#define _DEBUG
#ifdef _DEBUG
#define DEBUGLOG(...) ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, NULL, MODULE_NAME ": " __VA_ARGS__)
#else
#define DEBUGLOG(...) //
#endif

module AP_MODULE_DECLARE_DATA log_syslog_module;

typedef struct syslog_code {
	char *name;
	int	value;
} syslog_code_t;

/* must end with '.' */
static syslog_code_t syslog_facilities[] = {
	{ "local0", LOG_LOCAL0 },
	{ "local1", LOG_LOCAL1 },
	{ "local2", LOG_LOCAL2 },
	{ "local3", LOG_LOCAL3 },
	{ "local4", LOG_LOCAL4 },
	{ "local5", LOG_LOCAL5 },
	{ "local6", LOG_LOCAL6 },
	{ "local7", LOG_LOCAL7 },
	{ "user",   LOG_USER   },
	{ NULL, -1 },
};

static syslog_code_t syslog_priorities[] = {
	{ "debug",   LOG_DEBUG   },
	{ "info",    LOG_INFO    },
	{ "notice",  LOG_NOTICE  },
	{ "warning", LOG_WARNING },
	{ "err",     LOG_ERR     },
	{ "crit",    LOG_CRIT    },
	{ "alert",   LOG_ALERT   },
	{ "emerg",   LOG_EMERG   },
	{ NULL, -1 },
};

static ap_log_writer_init *default_log_writer_init = NULL;
static ap_log_writer      *default_log_writer      = NULL;

#define SYSLOG_HEADER_LEN 100
/**
 * syslog message is 2048 max length
 * http://tools.ietf.org/html/rfc5424#section-6.1
 */
#define SYSLOG_MAX_LENGTH 2048
#define SYSLOG_TIME_LEN sizeof("Oct 11 22:14:15")
#define SYSLOG_TIME_FMT "%b %d %H:%M:%S"
#define MAX_INT32_LEN   (sizeof("-2147483648") - 1)
#define MAX_INT64_LEN   (sizeof("-9223372036854775808") - 1)
#define ap_min(val1, val2)  (((val1) > (val2)) ? (val2) : (val1))
#define ap_max(val1, val2)  (((val1) < (val2)) ? (val2) : (val1))

typedef struct {
    char           *pri;
    char           *ident;
    char           *header;
    apr_size_t      pri_len;
    apr_size_t      ident_len;
    apr_size_t      header_len;
    apr_sockaddr_t *addr;
    apr_socket_t   *sock;
    apr_pool_t     *pool;
    char header_buf[SYSLOG_HEADER_LEN];
}syslog_t;

typedef struct {
    apr_array_header_t *syslog_list;
} log_syslog_config;


static void *create_log_syslog_server_conf(apr_pool_t *p, server_rec *s)
{
	log_syslog_config *config =
		(log_syslog_config *)apr_pcalloc(p, sizeof(*config));

    config->syslog_list = apr_array_make(p, 1, sizeof(syslog_t*));
	return (void *)config;
}

static syslog_t *get_syslog(log_syslog_config *config, syslog_t *handle)
{
    int i;
    syslog_t **elem_log = (syslog_t**)config->syslog_list->elts;

    for (i = 0; i < config->syslog_list->nelts; ++i) {
        if (handle == elem_log[i])
            return handle;
    }
    
	return NULL;
}

static apr_status_t
set_unix_domain(apr_pool_t *pool, server_rec *s, apr_sockaddr_t *addr, char *text,
    apr_size_t len)
{
    if (len > sizeof((struct sockaddr_un *) 0)->sun_path) {
        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s, "path \"%s\" is too long", text);
        return  APR_EBADPATH;
    }

    addr->hostname = text;
    addr->family = AF_UNIX;
    return APR_SUCCESS;
}

static  syslog_t* log_set_syslog(apr_pool_t *pool, server_rec *s, const char *name) 
{
	DEBUGLOG("log_set_syslog is called with: %s", name);

    log_syslog_config *config;
    int flag_local, facility, priority;
    const char *p, *last;
    char *ident;  
    syslog_code_t *code;
    apr_size_t len;
    apr_sockaddr_t *addr, sockaddr;
    apr_status_t rv;
    syslog_t *log;

    enum {
        sw_facility = 0,
        sw_priority,
        sw_address,
        sw_port,
        sw_ident,
        sw_done
    } state;
    
    flag_local = 0;
    p = name;
    ident = NULL;
    facility = -1;
    priority = -1;
    len = 0;
    state = sw_facility;
    config = ap_get_module_config(s->module_config, &log_syslog_module);
    /**
     * format example:
     *     syslog:user:info:127.0.0.1:514:ident
     *     syslog:user:info:/dev/log:ident
     *     syslog:user:info:127.0.0.1::ident
     *         is short for syslog:user:info:127.0.0.1:514:ident
     *     syslog:user:info:/dev/log
     *         is short for syslog:user:info:/dev/log:APACHE
     *     syslog:user:info:127.0.0.1
     *         is short for syslog:user:info:127.0.0.1:514:APACHE
     *     syslog:user::/dev/log:ident
     *         is short for syslog:user:info:/dev/log:ident
     *     syslog:user:info::ident
     *         is short for syslog:user:info:/dev/log:ident
     *     syslog:user:info
     *         is short for syslog:user:info:/dev/log:APACHE
     *     syslog:user
     *         is short for syslog:user:info:/dev/log:APACHE
     */
    while (state != sw_done) {
       last = p;  
       while (*p && (*p) != ':') p++;

       switch (state) {
           case sw_facility:
               len = p - last;
               for(code = syslog_facilities; code->name; code++) {
                   if (len == strlen(code->name) && 
                       strncmp(code->name, last, len) == 0) 
                   {
                       facility = code->value;
                       break;
                   }
               }
               if (facility == -1) {
                   DEBUGLOG("facility not found");
                   return NULL;
               }
               state = sw_priority;
               break;
           case sw_priority:
               len = p - last;
               if (len == 0) {
                   priority = LOG_INFO;
               } else {
                   for(code = syslog_priorities; code->name; code++) {
                       if (len == strlen(code->name) && 
                           strncmp(code->name, last, len) == 0) 
                       {
                           priority = code->value;
                           break;
                       }
                   }
               }
               if (priority == -1) {
                   DEBUGLOG("priority not found");
                   return NULL;
               }
               state = sw_address;
               break;
           case sw_address:
               len = p - last;
               if (len == 0) {
                   rv = set_unix_domain(pool, s, &sockaddr,
                      CUSTOM_LOG_FILE, sizeof(CUSTOM_LOG_FILE) - 1);

                   state = sw_ident;
               } else {
                   char *host_str, *scope_id;
                   char *url;
                   apr_port_t port;

                   url = apr_pstrndup(pool, last, len);
                   rv = apr_parse_addr_port(&host_str, &scope_id, &port, url, pool);
                   DEBUGLOG("address parse %s:%s:%d", host_str, scope_id,port);
                   if (rv != APR_SUCCESS || *host_str == '/') {
                       flag_local = 1;
                       rv = set_unix_domain(pool, s, &sockaddr, url, len);
                       state = sw_ident;
                   } else {
                       sockaddr.hostname = host_str;
                       if (*host_str == '[')
                           sockaddr.family = AF_INET6;
                       else
                           sockaddr.family = AF_INET;
                       state = sw_port;
                   }
                   
               }
               if (rv != APR_SUCCESS) {
                   DEBUGLOG("address parse failed");
                   return NULL;
               }
               break;
           case sw_port: 
               {
                   char *port_str;
                   unsigned int port;

                   len = p - last;
                   if (len == 0) {
                           sockaddr.port = 514;
                   } else {
                        port_str = apr_pstrndup(pool, last, len);
                        port = atoi(port_str);                           
                        if (port<=0 || port > 65535) {
                            DEBUGLOG("port parse failed");
                            return NULL;
                        } else {
                            sockaddr.port = port;
                        }
                   }
                   state = sw_ident;
               }
               break;
           case sw_ident:
               len = p - last;
               ident = apr_pstrndup(pool, last, len);
               state = sw_done;
               break;
           default:
               break;
       }
       if (*p) {
            p++;
       }
    }
#ifndef APR_HAVE_SOCKADDR_UN
    if (flag_local) {
        struct sockaddr_un unx;
        unx.sun_family = AF_UNIX;
        apr_cpystrn(unx.sun_path, sockaddr.hostname, sizeof(unx.sun_path));
        addr = apr_pcalloc(pool, sizeof(*addr));
        addr->pool = pool;
        addr->hostname = apr_pstrdup(pool, sockaddr.hostname);
        addr->family = AF_UNIX;
        addr->port = sockaddr.port;
        addr->salen = sizeof(struct sockaddr_un);
        memcpy(&addr->sa, &unx, addr->salen);
    }
    else 
#endif
    {
        rv = apr_sockaddr_info_get(&addr, sockaddr.hostname, sockaddr.family,
                               sockaddr.port, 0, pool);
        if (rv != APR_SUCCESS) {
            DEBUGLOG("apr_sockaddr_info_get failed:");
            return NULL;
        }
    }
    syslog_t **log_p = (syslog_t**)apr_array_push(config->syslog_list);
    log = apr_pcalloc(pool, sizeof(*log));
    if (!log || !log_p) {
        DEBUGLOG("apr_array_push failed");
        return NULL;
    }
    *log_p = log;

    if (!ident) {
        log->ident = AP_SERVER_BASEPRODUCT;
        log->ident_len = sizeof(AP_SERVER_BASEPRODUCT) - 1;
    } else {
        log->ident = ident;
        log->ident_len = strlen(log->ident);
    }
    log->addr = addr;
    log->pri = apr_psprintf(pool, "<%d>", (facility << 3) + priority);
    log->pri_len = strlen(log->pri);
    log->header = log->header_buf;
    log->pool = pool;
	DEBUGLOG("log_set_syslog is called successfully with: %s", name);
    return log; 
}
/*
 * log_syslog_writer_init and log_set_syslog work like:
 *
 * if name matches "syslog:"
 *   parse {"facility}:{priority}:{path}:{port}:{ident}",
 *   and save as syslog object in syslog_list 
 *
 * @return pointer to the element of syslog_list
 */
static void *log_syslog_writer_init(apr_pool_t *p, server_rec *s, const char *name) 
{
	DEBUGLOG("log_writer_init is called with: %s", name);
    /**
     * format example:
     * CustomLog syslog:local1:info:127.0.0.1:514:ident combined
     */
	// starts with syslog:
	if(strstr(name, CUSTOM_LOG_PREFIX) == name) {
        syslog_t *sys_log;

        if (sys_log = log_set_syslog(p, s, name + sizeof(CUSTOM_LOG_PREFIX) - 1)) {
            return sys_log;
        }

		ap_log_error(
				APLOG_MARK,
				APLOG_CRIT,
				APR_EGENERAL,
				s,
				MODULE_NAME ": Invalid syslog facility/priority => %s",
				name
			    );
		return NULL;
	}

	if(default_log_writer_init != NULL && default_log_writer_init != log_syslog_writer_init) {
		return default_log_writer_init(p, s, name);
	}
	return NULL;
}

static void open_syslog_connection(request_rec *r, syslog_t *handle)
{
    apr_status_t rv;
    apr_socket_t *sock;

    rv = apr_socket_create(&sock, handle->addr->family, 
                        SOCK_DGRAM, 0, handle->pool);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server, "apr_socket_create failed");
        return;
    }
#ifdef USE_SENDV
    rv = apr_socket_opt_set(sock, APR_SO_RCVBUF, 0);
    if (rv != APR_SUCCESS) {
        DEBUGLOG("apr_socket_opt_set APR_SO_RCVBUF failed");
        return;
    }
#endif
    rv = apr_socket_opt_set(sock, APR_SO_REUSEADDR, 1);
    if (rv != APR_SUCCESS) {
        DEBUGLOG("apr_socket_opt_set APR_SO_REUSEADDR failed");
        return;
    }

    /*rv = apr_socket_timeout_set(sock, 0);
    if (rv != APR_SUCCESS) {
        DEBUGLOG("apr_socket_timeout_set 0 failed");
        return;
    }*/
#ifdef USE_SENDV
    rv = apr_socket_connect(sock, handle->addr);
    if (rv != APR_SUCCESS) {
        DEBUGLOG("apr_socket_connect failed");
        return;
    }

    rv = apr_socket_shutdown(sock, APR_SHUTDOWN_READ);
    if (rv != APR_SUCCESS) {
        DEBUGLOG("apr_socket_shutdown failed");
        return;
    }
#endif
    handle->sock = sock;
}


static void syslog_prebuild_header(request_rec *r, syslog_t *handle)
{
    char pid_buf[MAX_INT64_LEN];
    apr_size_t header_len, pid_len, ident_len;

    pid_t pid = getpid();
    pid_len = apr_snprintf(pid_buf, MAX_INT64_LEN, "%" APR_PID_T_FMT, pid);
    
    header_len = apr_snprintf(handle->header, SYSLOG_HEADER_LEN,
                 " %s %s[%s]: ",
                 r->server->server_hostname,
                 handle->ident,
                 pid_buf);
            
    handle->header_len = header_len;
   
}
static apr_status_t wirte_syslog(request_rec *r, syslog_t *handle,
        const char *buf, apr_size_t len)
{
	DEBUGLOG("wirte_syslog is called");

    apr_status_t rv;
    struct iovec iovs[4];
    apr_size_t l, time_len;
    char time_buf[SYSLOG_TIME_LEN];
    apr_time_exp_t result;
    
    if (!handle->sock) {
        DEBUGLOG("!handle->sock0");
        open_syslog_connection(r, handle);
    }

    if (!handle->sock) {
        DEBUGLOG("!handle->sock1");
        return APR_ECONNABORTED;
    }
    
    if (handle->header_len == 0) {
        syslog_prebuild_header(r, handle);
    }

    apr_time_exp_gmt(&result, apr_time_now());
    rv = apr_strftime(time_buf, &time_len, SYSLOG_TIME_LEN, SYSLOG_TIME_FMT, &result);
    if (rv != APR_SUCCESS) {
        return rv;
    }   

    iovs[0].iov_base = (char *) handle->pri;
    iovs[0].iov_len = handle->pri_len;
    l = handle->pri_len;

    iovs[1].iov_base = (char *) time_buf;
    iovs[1].iov_len = time_len;
    l += time_len;

    iovs[2].iov_base = (char *) handle->header;
    iovs[2].iov_len = handle->header_len;
    l += handle->header_len;

    iovs[3].iov_base = (char *) buf;
    iovs[3].iov_len = ap_min(len, SYSLOG_MAX_LENGTH - l);

    DEBUGLOG("sending data = %s | %s | %s | %s", handle->pri, time_buf, handle->header, buf);
#ifdef USE_SENDV
    /**
     * There is a problem with apr_socket_sendv with UDP
     * It will send success at n time, and send failed at n+1 time
     * For example:
     * It will send success at first time, and send failed at second time.
     * Then success third time, and failed fourth time.
     * I think it it not flush at once, but no parameter help me.
     * I get sush a foolish idea to fix it that send each packet twice.
     */  
    rv = apr_socket_sendv(handle->sock, iovs, 4, &len);   
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server, "apr_socket_sendv send failed1");
        rv = apr_socket_sendv(handle->sock, iovs, 4, &len);   
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server, "apr_socket_sendv send failed2");
            return rv;
        }
    }
#else
    char *send_buf = apr_pstrcatv(r->pool, iovs, 4, &l);
    DEBUGLOG("sending data = %s", send_buf);
    rv = apr_socket_sendto(handle->sock, handle->addr, 0, send_buf, &l);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server, "apr_socket_sendto send failed");
    }
#endif
    DEBUGLOG("Leave wirte_syslog");
    return rv;  
}

/*
 * If handle is a pointer refering to syslog_list array,
 * it was initialized as a syslog writer in log_syslog_writer_init
 * and its dereferenced value is syslog.
 *
 * Otherwise this module is not responsible for the handle
 * and passes it to the default log_writer.
 *
 * @return apr_status_t
 */
static apr_status_t log_syslog_writer(
		request_rec *r,
		void *handle, 
		const char **portions,
		int *lengths,
		int nelts,
		apr_size_t len)
{
	DEBUGLOG("log_writer is called");

	log_syslog_config *config = ap_get_module_config(r->server->module_config, &log_syslog_module);

    if (get_syslog(config, handle)) {
        int i;
        char *s;
        char *str = apr_pcalloc(r->pool, len + 1);

        for (i = 0, s = str; i < nelts; ++i) {
               memcpy(s, portions[i], lengths[i]);
               s += lengths[i];
        }
        return wirte_syslog(r, handle, str, len);
    }

	if(default_log_writer != NULL && default_log_writer != log_syslog_writer) {
	    DEBUGLOG("default_log_wirter is called");
		return default_log_writer(r, handle, portions, lengths, nelts, len);
	}

	ap_log_rerror(APLOG_MARK, APLOG_CRIT, APR_EGENERAL, r, MODULE_NAME ": No valid ap_log_writer is available!");
	return APR_EGENERAL;
}

/*
 * This hook must be called:
 * - After mod_log_config's configuration phase,
 *   because log_writer{_init} can be changed by configuration directives.
 * - Before mod_log_config's open_logs,
 *   i.e. log_writer_init is called.
 *
 */
static int log_syslog_open_logs(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
{
	static APR_OPTIONAL_FN_TYPE(ap_log_set_writer_init) *set_writer_init;
	static APR_OPTIONAL_FN_TYPE(ap_log_set_writer) *set_writer;

	set_writer_init = APR_RETRIEVE_OPTIONAL_FN(ap_log_set_writer_init);
	set_writer = APR_RETRIEVE_OPTIONAL_FN(ap_log_set_writer);

	default_log_writer_init = set_writer_init(log_syslog_writer_init);
	default_log_writer = set_writer(log_syslog_writer);

	return APR_SUCCESS;
}

static void log_syslog_register_hooks(apr_pool_t *p)
{
	static const char * const suc[] = {
		"mod_log_config.c",
		NULL
	};

	ap_hook_open_logs(log_syslog_open_logs, NULL, suc, APR_HOOK_FIRST);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA log_syslog_module = {
	STANDARD20_MODULE_STUFF, 
	NULL,                  /* create per-dir    config structures */
	NULL,                  /* merge  per-dir    config structures */
	create_log_syslog_server_conf,                  /* create per-server config structures */
	NULL,                  /* merge  per-server config structures */
	NULL,                  /* table of config file commands       */
	log_syslog_register_hooks  /* register hooks                      */
};
